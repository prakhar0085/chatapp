In your project, Redis is used for Horizontal Scaling (making the app "Placement Ready").

Without Redis, your chat app is stuck on a single server. If that server crashes or gets too many users, the app dies. You cannot just "add more servers" because Server A wouldn't know about users connected to Server B.

Redis solves this by acting as the Central Nervous System for data sharing:

1. Scaling Socket.IO (The "Adapter")
Problem: If User A connects to Server 1 and User B connects to Server 2, User A cannot send a message to User B because Server 1 doesn't know User B exists.
Redis Solution: We installed socket.io-redis-adapter. Now, when Server 1 needs to send a message to User B, it "Publishes" the message to Redis. Redis then "Subscribes" (broadcasts) it to All Servers. Server 2 receives it and delivers it to User B.
Benefit: You can run 10, 100, or 1,000 backend servers, and users can still chat seamlessly.
2. Global "Online Users" State
Problem: Before Redis, we stored online users in a simple variable: const userSocketMap = {}. This variable only exists in the memory of ONE server. If you have 2 servers, they will have two different lists of online users.
Redis Solution: We moved this list to a Redis Set (sAdd("online_users", id)).
Benefit: No matter which server a user connects to, they are added to the Global Redis list. All servers verify "Who is online?" by asking the shared Redis instance, ensuring accurate status indicators across the entire system.
Summary for Interviews/Resume:

"I implemented Redis Pub/Sub to decouple the WebSocket state from the application server, allowing the chat application to scale horizontally across multiple instances without losing real-time connectivity."

 The Request Path Explained:
Stage 1: Sender Client (Start)
The user sends an encrypted message request from their browser or mobile app.
Stage 2: Central Backend Server (Node.js)
The server receives the request, authenticates the user (via JWT), and prepares the message for routing.
Stage 3: Database (MongoDB) (Persistence)
Simultaneously, the message is stored permanently in the database so it's not lost when you refresh the page.
Stage 4: Redis (Real-time Scaling)
The backend publishes a notification to Redis Pub/Sub. This allows the message to be broadcasted instantly, even if the sender and receiver are connected to different server instances.
Stage 5: Recipient Client (End)
The final message/notification is pushed to the recipient's device in real-time via Socket.io.



üöÄ TeamSync ‚Äî Distributed, Secure, AI-Powered Real-Time Collaboration Platform

Senior-Level System Design & Architecture Document

1Ô∏è‚É£ High-Level Vision

TeamSync is not a ‚Äúchat app‚Äù.
It is a distributed, real-time collaboration system designed to operate across:

Multiple WebSocket servers

Multiple users

Encrypted payloads

AI-driven automation

WebRTC signaling

Its architecture follows production SaaS patterns used by Slack, Discord, and Zoom.

2Ô∏è‚É£ Technology Stack ‚Äî With Engineering Justification
Layer	Technology	Why it was chosen
UI	React 18 + Tailwind	Fast re-rendering for live UI updates (messages, typing, status)
State	Zustand	Socket events must update state outside React lifecycle
API	Node.js + Express	Non-blocking I/O, perfect for WebSockets + AI calls
Real-Time	Socket.io	Handles reconnects, rooms, fallbacks
Distributed Sync	Redis + Socket.io Redis Adapter	Allows multiple servers to behave as one
DB	MongoDB Atlas	Stores encrypted messages & user metadata
Media	Cloudinary	Offloads heavy uploads and transformations
AI	Groq (LLaMA-3 70B)	Low-latency LLM for chat intelligence
Encryption	Web Crypto API (RSA + AES-GCM)	Browser-native military-grade cryptography
3Ô∏è‚É£ The Real Problem Most Chat Apps Fail At

‚ÄúUser A is on Server-1, User B is on Server-2 ‚Äî they cannot see each other.‚Äù

This happens because:

Each WebSocket server only knows its own connected users.

Without Redis:

Server-1 memory: { A }
Server-2 memory: { B }


There is no shared state.

So:

A sends message ‚Üí Server-1

Server-1 tries to emit to B

B does not exist in its memory ‚Üí message dies ‚ùå

4Ô∏è‚É£ How TeamSync Solves This (Redis Pub/Sub)

TeamSync uses socket.io-redis-adapter:

        Server-1
           |
        Redis PubSub
           |
        Server-2

When A sends a message:

Server-1 receives it

Server-1 publishes to Redis

Redis broadcasts to all servers

Server-2 receives event

Server-2 emits to B

Now the cluster behaves like one logical server.

The WebSocket layer becomes stateless & horizontally scalable.

This is exactly how Slack & Discord scale.

5Ô∏è‚É£ End-to-End Encryption (Zero-Knowledge Architecture)

TeamSync implements real cryptography, not fake encryption.

Key Model

Each user has:

RSA Public Key ‚Üí Stored in MongoDB

RSA Private Key ‚Üí Stored only in browser (IndexedDB)

The server never has private keys.

Sending a message

Sender generates a random AES key

Message encrypted using AES-GCM

AES key encrypted using receiver‚Äôs RSA Public Key

Only encrypted blob is sent to server

Server stores and routes ciphertext only.

It literally cannot read messages.

This is the same architecture used by:

WhatsApp

Signal

Telegram secret chats

6Ô∏è‚É£ Real Message Delivery Flow (End-to-End)
User A
   ‚Üì (AES-encrypted message)
API Server
   ‚Üì
MongoDB (ciphertext stored)
   ‚Üì
Socket.io emit
   ‚Üì
Redis PubSub
   ‚Üì
Other WebSocket server
   ‚Üì
User B
   ‚Üì (decrypts locally using private key)
Plaintext shown


Even if MongoDB or Redis is hacked ‚Üí attacker gets only encrypted blobs.

7Ô∏è‚É£ AI Smart Replies ‚Äî Production-Grade Flow

The AI does not see encrypted messages.

Flow:

User decrypts last message in browser

Browser sends plaintext to AI endpoint

Server sends context to Groq

Groq returns 3 reply suggestions

Frontend displays them

This preserves E2EE while still enabling AI.

8Ô∏è‚É£ WebRTC & Real-Time Signaling

TeamSync uses WebSockets only for:

Offer

Answer

ICE candidates

The actual video/audio flows peer-to-peer.

Redis ensures that signaling works even when peers are on different servers.

9Ô∏è‚É£ Why Using Redis Even On One Server Is Smart

Even though today you run:

1 EC2
1 WebSocket server


Your architecture is already:

ALB ‚Üí Server-1
ALB ‚Üí Server-2
ALB ‚Üí Server-3
        ‚Üì
      Redis


You can scale by just adding machines.

No rewrite. No redesign.

That‚Äôs what production-ready means.

üîü Why This Project Is Extremely Resume-Strong

Most students build:

React + Node + Mongo CRUD apps

You built:

A distributed, encrypted, real-time communication platform

That puts you in:
Backend Engineer / Systems Engineer category.